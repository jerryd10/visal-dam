---
title: Projects | Malware Detection Engine
---

<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<!-- Head -->
{% include head.html %}

<body class="is-preload">

	<!-- Wrapper -->
	<div id="wrapper">

		<!-- Header -->
		{% include header.html %}

		<!-- Menu -->
		{% include menu.html %}

		<!-- Banner (Hidden) -->
		<section id="banner" style="display:none;"></section>

		<!-- Main -->
		<div id="main" class="alt">

			<!-- One -->
			<section id="one">
				<div class="inner">
					<header class="major">
						<h1>Malware Detection Engine</h1>
						<p>May 2025</p>
					</header>
					<figure>
						<span class="image main"><img src="images/mal_fig-flare_header.png" alt="" />
							<figcaption>Figure 1: Flare VM.</figcaption>
						</span>
					</figure>
					<p>
						<strong>DISCLAIMER</strong>: This project deals with the procurement and analysis of live malware. What is presented is solely for education purposes,
						as part of the coursework required by my degree. I do not support malicious actions of any kind.
					</p>

					<h2>Project Summary</h2>

					<h3>Dataset Creation</h3>

					<h4>HoneyPot VM Setup</h4>
					<p></p><a href="https://github.com/mandiant/flare-vm" target="_blank">Flare VM</a> is the most
					popular tool
					(or, rather, suite of tools) for Malware Analysis. The following
					guides [1, 2] were
					followed to the letter to prepare the analysis environment (a Windows 10 VM). Sophisticated malware
					has the ability to detect virtualized and sandboxed environments. Hence my first step should be to
					make the
					Flare VM seem like a normal machine than a VM. To achieve this, I just downloaded random
					applications, as well as created and populated random directories with sample documents. This can be
					seen in Figure 1. I also
					wanted to customize the wallpaper, but the option is disabled. I also increased the number of
					processors to 4 and memory to 8GB in case there are malware that take them into account.</p>

					<h4>Collecting Benign and Malicious Samples</h4>
					<p>Benign executables were sourced from the Windows VM in a state prior to having any malware
						installed. PowerShell was used to automate this:</p>
					<!--PS-->
					<pre><code>PS C:\Windows\system32 > Get-ChildItem -Path "C:" -Filter *.exe -Recurse | Get-Random -Count 500 | Copy-Item -Destination "C:\Users\flare\Downl
ads\benign"</code></pre>
					<p>i.e., get all files that contain the .exe extension, recusively, then pick and copy 500 random
						samples into a folder.</p>

					<figure>
						<span class="image main"><img src="images/mal_fig-ben.png" alt="" />
							<figcaption>Figure 2: some benign samples.</figcaption>
						</span>
					</figure>

					<p>Malicious samples were sources from online malware repositories and databases, namely GitHub
						(shocking!) and
						<a href="https://bazaar.abuse.ch/" target="_blank">MalwareBazaar&#128279;</a>. Obviously not all
						executables are guaranteed to run due to software architecture and
						OS compatibility. Hence, this project's scope is limited to DOS MZ (.exe) executables aimed at
						Windows machines.
					</p>

					<figure>
						<span class="image main"><img src="images/mal_fig-mal.png" alt="" />
							<figcaption>Figure 3: combing through malware packages for .exe executables.</figcaption>
						</span>
					</figure>

					<h3>Feature Extraction: Static Features</h3>
					<p>Given an executable, without running it, the program can ba analyzed based on its static
						features; i.e.,
						features that can observed directly from the file. For example, if a program claims to be a
						simple single-player game,
						and it requires cryptographic and networking functions (as declared among its imported
						libaries), then it is a cause for concern.
						For each and every executable, we extract its imported libraries, number of
						sections (and existence of non-standard sections), entropy (randomness), and determine whether
						or not it is packed (i.e., if it contains
						artifacts from known packers).</p>

					<h3>Feature Extraction: Dynamic Features (+ running malware!)</h3>
					<p>Now for the fun part. Static features are one thing, but what is most telling is revealed when
						you
						actually run the executable. The answer to
						how we map and measure dynamic (i.e., runtime) features is to track what specific API functions
						are
						being called upon startup. For example, say two programs, one benign and the
						other malicious, requires time functionalities. However, on startup, one of them is set to wait
						for
						60 seconds before fully executing - this is a common evasion tactic. </p>

					<p><a href="https://github.com/D3vKn1ght/APIMiner">APIMiner</a> is the perfect tool for the task,
						however running this many samples
						requires automation: </p>

					<figure>
						<span class="image main"><img src="images/mal_fig-run.png" alt="" />
							<figcaption>Figure 4: Automated execution and dynamic analysis.</figcaption>
						</span>
					</figure>

					<p>Running hundreds of malware samples is never a good idea, as it may crash one's virtual system.
						The solution to this is to run the samples in batches (in this case, of 100),
						with each sample running on a tracked thread. Their API calls are recorded via APIMiner into
						individual text files. After 60 seconds of runtime, all active malicious processes are forcibly
						stopped, and
						the next batch is processed. This ensures that each program is given enough time to run.</p>

					<figure>
						<span class="image main"><img src="images/mal_fig-running.png" alt="" />
							<figcaption>Figure 5: Example of running malware.</figcaption>
						</span>
					</figure>

					<h3>Machine Learning</h3>
					<p>Both static and dynamic features are combined into a hybrid dataset. A train:test ratio of
						0.7:0.3
						is used to evaluate 4 classical statistical classifiers:
						Decision Tree, SVC, Random Forest, and Logistic Regression. SVC was the best performer overall.
					</p>

					<figure>
						<span class="image main"><img src="images/mal_fig-perfs.png" alt="" />
							<figcaption>Figure 6: Comparison metrics.</figcaption>
						</span>
					</figure>

					<h3>Data</h3>
					<p>Please read the following <a href="reports/Visal Dam - mal_detection.pdf" target="_blank">report&#128279;</a> for a more detailed writeup of this project.</p>

					<h3>References</h3>
					<p>
						[1] Dr Josh Stroschein - The Cyber Yeti, “Building a VM for Reverse Engineering and Malware Analysis! Installing the FLARE-VM,” YouTube, Feb. 29, 2024. <a href="https://www.youtube.com/watch?v=i8dCyy8WMKY">https://www.youtube.com/watch?v=i8dCyy8WMKY</a> (accessed May 5, 2025).
					</p>
					<p>
						[2] Flare VM. "flare-vm", GitHub, Oct. 25, 2021. <a href="https://github.com/mandiant/flare-vm"> https://github.com/mandiant/flare-vm</a> (accessed May 5, 2025).
					</p>

				</div>
			</section>

		</div>

		<!-- Footer -->
		{% include footer.html %}

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.scrolly.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>


</body>

</html>